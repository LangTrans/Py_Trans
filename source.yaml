notdefined:
  regex: (<var>)\s*\|\|\s*(.+)(?:$|\))
  tokens: [var,value]
pipe:
  regex: (.+)\|(.+)$
  tokens: [f1,f2]
  f2:
    call: [pipe]
print:
  regex: <tab>p(".*")$
  tokens: [tab,str]
arrow2list:
  regex: (<var>)\s*=>\s*(.+)
  tokens: [fun,list]
arrow_fun:
  regex: <tab>(<var>)<bracket>\s*=>\s*(.+)
  tokens: [tab,name,args,statement]
arrow:
  regex: \((.*)\)\s*=>\s*(.+)
  tokens: [arg,statement]
fun:
  regex: fun\s[A-Za-z_]+
  tokens: [name]
single_try:
  regex: <tab>try (.+) (.+) (.+)$
  tokens: [tab,try_state,err,except_state]
itself:
  regex: <tab>=(<var>)\.(.+)$
  tokens: [tab,var,rest]
ternary:
  regex: (=\s*|\()(.+)\?(.+):(.+)($|\))
  tokens: [start,bol,tru,fals,end]
  bol,tru,fals:
    replace:
      - [<lstrip>]
      - [<rstrip>]
condition:
  regex: <tab>(<var>)<bracket> if (.+)$
  tokens: [tab,name,args,bol]
#Some Haskell Syntax
jrange:
  regex: (\d+),(\d+)\.\.(\d+)
  tokens: [jump,start,end]
range:
  regex: (,*)(\d+)\.\.(\d+)
  tokens: [comma,start,end]
  comma:
    replace:
      - ["^,",",*"]
listrange:
  regex: "!\\[(.+)\\]"
  tokens: [inside]
  inside:
    call: [jrange,range]

#-----------------------
chk_defined:
  regex: "!(<var>)"
  tokens: [var]
settings:
  loop: True
  variables:
    tab: ^(\t*)
    lstip: "^\\s{1,}"
    rstrip: "\\s{1,}$"
    var: "[A-Za-z0-9_]+"
    bracket: \((.+)\)
    